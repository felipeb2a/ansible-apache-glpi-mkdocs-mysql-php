# Gerar Certificado com o arquiv pfx
# openssl pkcs12 -in /home/usuario/meu_certificado.pfx -clcerts -nokeys -out certificado.crt
# openssl pkcs12 -in /home/usuario/meu_certificado.pfx -nocerts -nodes -out chave.key
# openssl pkcs12 -in /home/usuario/meu_certificado.pfx -cacerts -nokeys -out cadeia_intermediaria.crt

# Site scan dnssec
# https://dnssec-analyzer.verisignlabs.com/
# https://ftp.registro.br/pub/doc/configuracao_dnssec_dominio.pdf

# Site scan headers
# https://securityheaders.com

# Site scan ssl
# https://www.ssllabs.com/ssltest/analyze.html

# Site Check cadeia de certificado
# https://whatsmychaincert.com/
# https://www.sslshopper.com/ssl-checker.html

# O ataque SSI permite a exploração de um aplicativo Web injetando scripts em páginas HTML ou executando códigos remotamente
# Incluir no arquivo http.conf dentro do bloco <Directory /> a opção abaixo
# Options -Indexes -Includes

#Hide The Apache Version
ServerSignature Off
ServerTokens Prod

# Set HSTS env var only if HTTPS
RewriteCond %{HTTPS} on
RewriteRule ^ - [E=HSTS:1]

# Force http to https
#RewriteEngine On
#RewriteCond %{HTTPS} off
#RewriteCond %{SERVER_PORT} 80
#RewriteRule ^ https://%{HTTP_HOST}%{REQUEST_URI} [R=301,L]

# HSTS atenua variantes de ataques man in the middle (MiTM) onde o TLS pode ser retirado das comunicações com um servidor, deixando um usuário vulnerável a mais riscos.
# Parametro IF não funciona em versões anteriores ao 2.2, para utilizar adicione direto no arquivo ssl
# https://scotthelme.co.uk/hsts-the-missing-link-in-tls/
# https://hstspreload.org/ # site para verificar
#Header always set Strict-Transport-Security "max-age=63072000; includeSubdomains; preload" env=HSTS
<If "%{HTTPS} == 'on'">
    Header always set Strict-Transport-Security "max-age=63072000; includeSubdomains; preload"
</If>

#Proteger O Apache Contra Ataques De Clickjacking
#Header append X-FRAME-OPTIONS "SAMEORIGIN"
Header always set X-Frame-Options "SAMEORIGIN"

# Define fontes aprovadas de conteúdo que o navegador pode carregar. Pode ser uma contramedida eficaz para ataques de Cross Site Scripting (XSS)
# https://scotthelme.co.uk/content-security-policy-an-introduction/
# Verificar se vai carregar o css, js da pagina
## Vai carregar apenas css e js da pasta local do site
# Header set Content-Security-Policy "default-src 'self';"
## Vai carregar qualquer css js de paginas que voce adicionar na lista
# Header set  Content-Security-Policy: default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com/ajax/libs/baguettebox.js/1.10.0/baguetteBox.min.js; style-src 'self' https:*;
## Permitir tudo melhor nao aplicar se for para permitir tudo
Header add Content-Security-Policy "default-src *  data: blob: filesystem: about: ws: wss: 'unsafe-inline' 'unsafe-eval' 'unsafe-dynamic'; script-src * data: blob: 'unsafe-inline' 'unsafe-eval'; connect-src * data: blob: 'unsafe-inline'; img-src * data: blob: 'unsafe-inline'; frame-src * data: blob: ; style-src * data: blob: 'unsafe-inline'; font-src * data: blob: 'unsafe-inline';"

# Proteger Cross Site Tracing
TraceEnable off

# Quando um usuário clica em um link em um site, a origem, que o leva para outro site, o destino, o site de destino recebe informações sobre a origem de onde o usuário veio
# https://scotthelme.co.uk/a-new-security-header-referrer-policy/
Header always set Referrer-Policy "same-origin"

# O cabeçalho Permissions-Policy permite que os administradores do site especifiquem quais recursos da web e APIs são permitidos ou não em seu site.
# https://scotthelme.co.uk/goodbye-feature-policy-and-hello-permissions-policy/
Header set Permissions-Policy "geolocation=(self), microphone=(self), camera=(self), fullscreen=(self), payment=(self)"

# Proteger X-Content-Type-Option
Header set X-Content-Type-Options nosniff

#Desativar ETag
<IfModule mod_headers.c> 
    Header unset ETag 
</IfModule> 
FileETag None

#Apache Seguro Contra Ataques XSS
<IfModule mod_headers.c>
    Header set X-XSS-Protection "1; mode=block"
</IfModule>

# O cabeçalho de resposta define como os rastreadores devem indexar URLs
<IfModule mod_headers.c>
    Header always set X-Robots-Tag "noindex, nofollow"
</IfModule>

#Proteger Cookies Com Sinalizador HTTPOnly
<IfModule mod_headers.c>
    Header edit Set-Cookie ^(.*)$ $1;HttpOnly;Secure
</IfModule>

#Proxy Reverso
LoadModule proxy_html_module modules/mod_proxy_html.so
    
    # Caso utilize o proxy segue abaixo sugestao de apontamento
    # DocHtml
    #ProxyPassMatch "(?i)^/DocHtml/(.*)$" http://192.168.0.9:9090/DocHtml/$1 # Remove o case sensitive na chamada da URL
    ##ProxyPass /DocHtml http://192.168.0.9:9090/DocHtml
    #ProxyPassReverse /DocHtml http://192.168.0.9:9090/DocHtml

#Modify httpd.conf with your document root directory to point Apache to your site’s files.
#Add the <IfModule prefork.c> section below to adjust the resource use settings.
#The settings shown below are a good starting point for a Linode 2GB:

<IfModule prefork.c>
    StartServers        5
    MinSpareServers     20
    MaxSpareServers     40
    MaxRequestWorkers   256
    MaxConnectionsPerChild 5500
</IfModule>

# Timeout
# O timeout do servidor Web Apache é de 300 segundos, o que pode torná-lo uma vítima de DDoS
# Valide se a opção está presente no arquivo httpd.conf
# Timeout 60
Timeout 180
KeepAlive On
KeepAliveTimeout 15
MaxKeepAliveRequests 500

# Mod Security
# O Mod Security funciona como um firewall para aplicações web de código aberto. Ele também auxilia na proteção dos sites e do próprio servidor web contra ataques de força bruta.
# apt-get install libapache2-mod-security
# após instalar habilite: a2enmod security2

# Desabilitar WebDAV
# Permite que clientes remotos manipulem arquivos no servidor
# linux a2dismod dav
# windows desabilite #Include conf/extra/httpd-dav.conf

# Desabilitar info_module
# linux a2dismod info
# windows desabilite o modulo LoadModule info_module modules/mod_info.so

# Alterar o Diretorio icons
# Quando instalado, por padrão o servidor web Apache cria um diretório chamado icons, que contém os ícones padrão do Apache que por vezes não são
# necessários a aplicação em execução no servidor. Então recomenda-se ao menos renomear este diretório para retirá-lo da configuração padrão e ser um recurso a menos conhecido pelo atacante
# linux mv icons icones

# Desbilitando o protocolo HTTP 1.0
# Windows habilitar LoadModule rewrite_module modules/mod_rewrite.so
# Linux a2enmod rewrite
RewriteEngine On
RewriteCond %{THE_REQUEST} !HTTP/1.1$
RewriteRule .* -[F]

# Proteger contra SQL Injection
RewriteCond %{QUERY_STRING} (<|%3C).*script.*(>|%3E) [NC,OR]
RewriteCond %{QUERY_STRING} GLOBALS(=|[|%[0-9A-Z]{0,2}) [OR]
RewriteCond %{QUERY_STRING} _REQUEST(=|[|%[0-9A-Z]{0,2})
RewriteRule ^(.*)$ index.php [F,L]

# SSL WINDOWS

## Habilitar em httpd.conf
#LoadModule ssl_module modules/mod_ssl.so
## para apache 2.4 ou posterior
#LoadModule socache_shmcb_module modules/mod_socache_shmcb.so

## Habilitar 
#Include conf/extra/httpd-ssl.conf

# Edite o arquivo /etc/httpd/conf.d/ssl.conf e procure por todas as ocorrências da variável SSLProtocol e deixe da seguinte maneira
## (se você configurou essa variável em algum virtual host, também deve alterar essa variável na configuração do virtual host!):

## SSLProtocol all +TLSv1.1 +TLSv1.2
## SSLProtocol all -SSLv3 -TLSv1 -TLSv1.1 +TLSv1.2 +TLSv1.3 # verificar se tem habilitado +TLSv1.3

## Mude para o SSLCipherSuite abaixo
## SSLCipherSuite AES256+EECDH:AES256+EDH:!aNULL
### SSLCipherSuite "EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !EDH !RC4"

## Habilitar o SSLHonorCipherOrder
## SSLHonorCipherOrder on

## Para o funcionameno correto do certificado temos que ter configurado os arquivos conforme abaixo
### Caso o certificado intermediario esteja quebrado utilize o site https://whatsmychaincert.com/ para corrigir
### Colar o conteudo do arquivo .crt e depois em generate, substitua o arquivo .crt pelo novo gerado para correção
## SSLCertificateFile    /etc/letsencrypt/live/idd-mex.org/cert.pem
## SSLCertificateKeyFile /etc/letsencrypt/live/idd-mex.org/privkey.pem
## SSLCertificateChainFile /etc/letsencrypt/live/idd-mex.org/chain.pem

# Certificate Authority Authorization (CAA) é um mecanismo de segurança que permite que os proprietários de domínio # especifiquem quais Certificate Authorities (CAs) têm permissão para emitir certificados SSL/TLS para seu domínio. A política # CAA é aplicada por meio de registros DNS (Domain Name System), fornecendo uma camada extra de segurança contra emissão de # certificados não autorizados.
# Quando uma Certificate Authority recebe uma solicitação de certificado para um domínio, é necessário verificar os registros # CAA do domínio antes de
# emitir o certificado. Sem um CAA, é possível ter certificados emitidos para um domínio por uma autoridade de certificação # não aprovada.
# O CAA é implementado como um registro de recurso DNS (tipo CAA). Os proprietários de domínio adicionam registros CAA ao seu # arquivo de zona DNS, especificando
# quais CAs têm permissão para emitir certificados para esse domínio. Para permitir que o Let's Encrypt emita certificados, o # registro ficaria assim:
# example.com. IN CAA 0 issue "letsencrypt.org".

# Bloquear Acesso Direto a Arquivos Sensíveis
<FilesMatch "(^\.ht|\.ini|\.log|\.bak|\.sql|\.sh|\.bat|composer\.(json|lock))">
    Require all denied
</FilesMatch>

# Bloquear acesso direto à raiz, caso queira alguma outra pasta basta editar condicao
# Eu apenas adicionei a pagina index.php com os cabecalhos que resolveu
#RewriteEngine On # Ativar reescrita de URL
#RewriteCond %{REQUEST_URI} ^/?$
#RewriteRule ^.*$ /403.html [R=403,L]

# deve adicionar depois de directory
# Cria uma página em branco para respostas 403
#Alias /403.html "C:/inetpub/wwwroot/403.html"

#<Files "403.html">
#    Require all granted
#</Files>

# PAGINA 403.php ou index.php
#<?php
#// Redirecionar para HTTPS, se não estiver usando
#if (empty($_SERVER['HTTPS']) || $_SERVER['HTTPS'] === "off") {
#    $httpsUrl = "https://" . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
#    header("Location: $httpsUrl", true, 301); // Redirecionamento permanente
#    exit;
#}
#
#// Código de resposta 403
#//http_response_code(403);
#
#// Definir código de status 403 manualmente
#header($_SERVER["SERVER_PROTOCOL"]." 403 Forbidden");
#
#// Cabeçalhos de segurança
#if (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') {
#    header('Strict-Transport-Security: max-age=63072000; includeSubDomains; preload'); // HSTS (apenas se HTTPS)
#}
#
#header('X-Content-Type-Options: nosniff'); // Proteção contra MIME sniffing
#header('X-Frame-Options: SAMEORIGIN'); // Proteção contra Clickjacking
#header('X-XSS-Protection: 1; mode=block'); // Proteção contra XSS
#header('X-Robots-Tag: noindex, nofollow'); // Prevenção de indexação
#header('Referrer-Policy: same-origin'); // Política de referrer
#header("Permissions-Policy: geolocation=(self), microphone=(self), camera=(self), fullscreen=(self), payment=(self)"); // #Controle de permissões
#
#// Content Security Policy flexível
#header("Content-Security-Policy: default-src * data: blob: filesystem: about: ws: wss: 'unsafe-inline' 'unsafe-eval' #'unsafe-dynamic'; script-src * data: blob: 'unsafe-inline' 'unsafe-eval'; connect-src * data: blob: 'unsafe-inline'; img-src #* data: blob: 'unsafe-inline'; frame-src * data: blob: ; style-src * data: blob: 'unsafe-inline'; font-src * data: blob: #'unsafe-inline'");
#
#// Desativar ETag
#header("ETag:");
#header("Cache-Control: no-store, no-cache, must-revalidate, max-age=0");
#
#// Proteção de cookies (descomente se necessário)
#// header('Set-Cookie: sessionId=abc123; HttpOnly; Secure', false);
#?>
#
#<!DOCTYPE html>
#<html>
#<head>
#  <meta charset="utf-8">
#  <title>403 Forbidden</title>
#</head>
#<body>
#  <h1>403 - Forbidden</h1>
#</body>
#</html>